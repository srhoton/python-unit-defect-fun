In the root folder of this repository, create a AWS Python 3.13 Lambda function. It should:
1. Read from a DynamoDB stream. The table name should come from an AWS AppConfig setting called "sourceTable"
2. It will potentially write to a DynamoDB table. The table name should come from the same AWS AppConfig setting called "destinationTable".
2. When it recieves a record, it's behavior should be the following:
2a. If the record is a new insert, It should:
    - Look for a matching record in the destination table for a PK with a value of "{customerId}", where customerId is the value of the "customerId" attribute in the incoming record, and the SK is "customer". If it finds that record, it should create a new record with a PK of "{customerId}|{unitId}" and a SK of "customerUnit", where unitId is the value of the "unitId" attribute in the incoming record. Add a createdAt attribute with the current timestamp.
   - If it cannot find a customerId that matches (or if the customerId is missing from the incoming record), it should follow the same logic as the previous step except it should look for a attribute in the source record of "locationId". If it finds a matching record, it should create a new record with a PK of "{locationId}|{unitId}" and a SK of "locationUnit", where unitId is the value of the "unitId" attribute in the incoming record. Add a createdAt attribute with the current timestamp.
   - Finally, if it cannot find a locationId that matches (or if the locationId is missing from the incoming record), it should look for an attribute in the source record of "accountId". If it finds a matching record, it should create a new record with a PK of "{accountId}|{unitId}" and a SK of "accountUnit", where unitId is the value of the "unitId" attribute in the incoming record. Add a createdAt attribute with the current timestamp.
   - If none of those 3 attributes match, it should log it cannot create a record and return a success response.
2b. If the record is an update, update the existing record. Follow the same logic as the previous step. First, see if there is a record in the destination table with a PK of "{customerId}|{unitId}" and a SK of "customerUnit". If it finds that record, it should update it with the new data, and add a updatedAt attribute with the current timestamp. If that record is not found, see if there is a record in the destination table with a PK of "{locationId}|{unitId}" and a SK of "locationUnit". If it finds that record, it should update it with the new data, and add a updatedAt attribute with the current timestamp. If that record is not found, see if there is a record in the destination table with a PK of "{accountId}|{unitId}" and a SK of "accountUnit". If it finds that record, it should update it with the new data, and add a updatedAt attribute with the current timestamp. If none of those records are found, it should log it cannot update a record and return a success response.
2c. If the record is a delete, delete the existing record. Follow the same logic as the previous step. First, see if there is a record in the destination table with a PK of "{customerId}|{unitId}" and a SK of "customerUnit". If it finds that record, it should update the record, adding a 'deletedAt' attribute with the current timestamp. If that record is not found, see if there is a record in the destination table with a PK of "{locationId}|{unitId}" and a SK of "locationUnit". If it finds that record, it should update the record, adding a 'deletedAt' attribute with the current timestamp. If that record is not found, see if there is a record in the destination table with a PK of "{accountId}|{unitId}" and a SK of "accountUnit". If it finds that record, it should update the record, adding a 'deletedAt' attribute with the current timestamp. If none of those records are found, it should log it cannot delete a record and return a success response.
3. Follow all rules provided in the previous steps. Make sure all code passes linting and formatting checks from Ruff. Ensure that the code uses and passes mypy type checking. Write test for all created code.
